 The root interface in the <i>collection hierarchy</i>.  A collection
 represents a group of objects, known as its <i>elements</i>.  Some
 collections allow duplicate elements and others do not.  Some are ordered
 and others unordered.  The JDK does not provide any <i>direct</i>
 implementations of this interface: it provides implementations of more
 specific subinterfaces like <tt>Set</tt> and <tt>List</tt>.  This interface
 is typically used to pass collections around and manipulate them where
 maximum generality is desired.

 <p><i>Bags</i> or <i>multisets</i> (unordered collections that may contain
 duplicate elements) should implement this interface directly.

 <p>All general-purpose <tt>Collection</tt> implementation classes (which
 typically implement <tt>Collection</tt> indirectly through one of its
 subinterfaces) should provide two "standard" constructors: a void (no
 arguments) constructor, which creates an empty collection, and a
 constructor with a single argument of type <tt>Collection</tt>, which
 creates a new collection with the same elements as its argument.  In
 effect, the latter constructor allows the user to copy any collection,
 producing an equivalent collection of the desired implementation type.
 There is no way to enforce this convention (as interfaces cannot contain
 constructors) but all of the general-purpose <tt>Collection</tt>
 implementations in the Java platform libraries comply.

 <p>The "destructive" methods contained in this interface, that is, the
 methods that modify the collection on which they operate, are specified to
 throw <tt>UnsupportedOperationException</tt> if this collection does not
 support the operation.  If this is the case, these methods may, but are not
 required to, throw an <tt>UnsupportedOperationException</tt> if the
 invocation would have no effect on the collection.  For example, invoking
 the <a href='#addAll(Collection)'>addAll(Collection)</a> method on an unmodifiable collection may,
 but is not required to, throw the exception if the collection to be added
 is empty.

 <p>Some collection implementations have restrictions on the elements that
 they may contain.  For example, some implementations prohibit null elements,
 and some have restrictions on the types of their elements.  Attempting to
 add an ineligible element throws an unchecked exception, typically
 <tt>NullPointerException</tt> or <tt>ClassCastException</tt>.  Attempting
 to query the presence of an ineligible element may throw an exception,
 or it may simply return false; some implementations will exhibit the former
 behavior and some will exhibit the latter.  More generally, attempting an
 operation on an ineligible element whose completion would not result in
 the insertion of an ineligible element into the collection may throw an
 exception or it may succeed, at the option of the implementation.
 Such exceptions are marked as "optional" in the specification for this
 interface.

 <p>It is up to each collection to determine its own synchronization
 policy.  In the absence of a stronger guarantee by the
 implementation, undefined behavior may result from the invocation
 of any method on a collection that is being mutated by another
 thread; this includes direct invocations, passing the collection to
 a method that might perform invocations, and using an existing
 iterator to examine the collection.

 <p>Many methods in Collections Framework interfaces are defined in
 terms of the java.lang.Object#equals(java.lang.Object) method.  For example,
 the specification for the <a href='#contains(Object) contains(Object o)'>contains(Object) contains(Object o)</a>
 method says: "returns <tt>true</tt> if and only if this collection
 contains at least one element <tt>e</tt> such that
 <tt>(o==null ? e==null : o.equals(e))</tt>."  This specification should
 <i>not</i> be construed to imply that invoking <tt>Collection.contains</tt>
 with a non-null argument <tt>o</tt> will cause <tt>o.equals(e)</tt> to be
 invoked for any element <tt>e</tt>.  Implementations are free to implement
 optimizations whereby the <tt>equals</tt> invocation is avoided, for
 example, by first comparing the hash codes of the two elements.  (The
 java.lang.Object#hashCode() specification guarantees that two objects with
 unequal hash codes cannot be equal.)  More generally, implementations of
 the various Collections Framework interfaces are free to take advantage of
 the specified behavior of underlying java.lang.Object methods wherever the
 implementor deems it appropriate.

 <p>This interface is a member of the
 <a href="{@docRoot}/../technotes/guides/collections/index.html">
 Java Collections Framework</a>.
 <DL><DT><B>Authors:</B></DT><DD>Josh Bloch</DD><DD>Neal Gafter</DD></DL><DL><DT><B>Version:</B></DT><DD>%I%, %G%</DD></DL><DL><DT><B>See Also:</B></DT><DD><a href='../java/util/Set.html' title='Set'>Set</a></DD><DD><a href='../java/util/List.html' title='List'>List</a></DD><DD><a href='../java/util/Map.html' title='Map'>Map</a></DD><DD><a href='../java/util/SortedSet.html' title='SortedSet'>SortedSet</a></DD><DD><a href='../java/util/SortedMap.html' title='SortedMap'>SortedMap</a></DD><DD><a href='../java/util/HashSet.html' title='HashSet'>HashSet</a></DD><DD><a href='../java/util/TreeSet.html' title='TreeSet'>TreeSet</a></DD><DD><a href='../java/util/ArrayList.html' title='ArrayList'>ArrayList</a></DD><DD><a href='../java/util/LinkedList.html' title='LinkedList'>LinkedList</a></DD><DD><a href='../java/util/Vector.html' title='Vector'>Vector</a></DD><DD><a href='../java/util/Collections.html' title='Collections'>Collections</a></DD><DD>java.util.Arrays</DD><DD><a href='../java/util/AbstractCollection.html' title='AbstractCollection'>AbstractCollection</a></DD></DL><DL><DT><B>Since:</B></DT><DD>1.2</DD></DL>